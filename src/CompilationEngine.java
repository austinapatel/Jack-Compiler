
// Created by Austin Patel on 7/23/16 at 8:54 PM

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;

/**
 * Effects the actual compilation output. Gets its input from a JackTokenizer
 * and emits its parsed structure into an output file/stream. The output is
 * generated by a series of compilexxx ( ) routines, one for every syntactic
 * element xxx of the Jack grammar. The contract between these routines is that
 * each compilexxx ( ) routine should read the syntactic construct xxx from the
 * input, advance ( ) the tokenizer exactly beyond xxx, and output the parsing
 * of xxx. Thus, compilexxx ( ) may only be called if indeed xxx is the next
 * syntactic element of the input.
 */
public class CompilationEngine {

	private BufferedWriter writer;
	private ArrayList<String> fileContent;
	private String tokenType, token, line, className;
	private int lineNumber, indent;
	private boolean isVoid, isMethod;

	private SymbolTable symbolTable;
	private VMWriter vm;

	private final char[] opVals = new char[] { '+', '-', '*', '/', '&', '|', '<', '>', '=' };
	private final String[] statementTypes = new String[] { "let", "if", "while", "do", "return" };
	private final String[] keywordConstants = new String[] { "true", "false", "null", "this" };

	/**
	 * Creates a new compilation engine with the given input and output. The
	 * next routine called must be "compileClass()".
	 */
	public CompilationEngine(File input, File output) {
		// Initialize the SymbolTable
		symbolTable = new SymbolTable();

		// Initialize the VMWriter
		vm = new VMWriter(new File(output.getAbsolutePath().replace("_Compiler.xml", ".vm")));
		className = input.getName().replace("T_Token.xml", "");

		// Open the input/output streams for reading the token stream and
		// writing it into a *.vm file. Additionally, it reads the input file
		// and stores its parsed content.
		try {
			readAllInput(input);

			writer = new BufferedWriter(new FileWriter(output));
		} catch (IOException e) {
			System.out.println("Failed to read the input file and open the output writer.");
			e.printStackTrace();
		}
	}

	/**
	 * Reads the whole input file, parses its data and store it in the
	 * "fileContent" variable.
	 */
	private void readAllInput(File input) throws IOException {
		fileContent = (ArrayList<String>) Files.readAllLines(input.toPath());

		// Remove the first and last lines from the input file because they are
		// the "token" opening and closing tags.
		fileContent.remove(0);
		fileContent.remove(fileContent.size() - 1);
	}

	/**
	 * Advances the input reader and stores the current token type and the value
	 * of the token. Adds variables to the SymbolTable when they are encountered
	 * and prints out information related to it.
	 */
	private void advance() {
		// Parse the token stream XML into its various parts.
		String currentLine = fileContent.get(lineNumber);

		tokenType = currentLine.substring(1, currentLine.indexOf('>'));
		currentLine = currentLine.substring(currentLine.indexOf('>') + 2);
		token = currentLine.substring(0, currentLine.indexOf('<') - 1);
		line = fileContent.get(lineNumber);

		// Handle special tokens that relate to operations.
		if (token.equals("&lt;"))
			token = "<";
		else if (token.equals("&gt;"))
			token = ">";
		else if (token.equals("&amp;"))
			token = "&";
		else if (token.equals("&quot"))
			token = "\"";

		lineNumber++;
	}

	/** Compiles a complete class. */
	public void compileClass() {
		advance();

		// "class" keyword
		if (!token.equals("class")) {
			System.out.println("Expected a class declaration.");
			return;
		}

		writeXML("<class>");
		indent++;
		writeXML(line);

		// Class name
		advance();
		if (!tokenType.equals("identifier")) {
			System.out.println("Invalid class name.");
			return;
		}

		writeXML(line);

		// Symbol '{'
		advance();
		if (!token.equals("{")) {
			System.out.println("Expected an opening brace after class name.");
			return;
		}
		writeXML(line);

		// Keep looking for * class variable declaration | * subroutine
		// declaration until a '}' is found.

		boolean varDecFinished = false;

		while (true) {
			advance();
			if (token.equals("}")) {
				// Class ending brace
				writeXML(line);

				// Write final class tag
				indent--;
				writeXML("</class>");

				try {
					writer.flush();
					writer.close();
				} catch (IOException e) {
					System.out.println("Failed to close and flush the writer.");
					e.printStackTrace();
				}

				break;
			} else if (token.equals("constructor") || token.equals("function") || token.equals("method")) {
				// Subroutine declaration
				varDecFinished = true;

				stepBack();
				compileSubroutine();
			} else if (token.equals("static") | token.equals("field")) {
				// Class variable declaration

				// Don't allow variable declarations after subroutine
				// declarations
				if (varDecFinished) {
					System.out.println("A class variable declaration cannot appear after a subroutine definition.");
					break;
				}

				stepBack();

				compileClassVarDec();
			} else { // Invalid entry
				System.out
						.println("Expected a subroutine declaration, a class variable declaration or a closing brace.");
				break;
			}
		}

		try {
			vm.close();
			writer.close();
		} catch (IOException e) {
			System.out.println("Failed to close the BufferedWriter.");
			e.printStackTrace();
		}
	}

	/** Compiles a static declaration or a field declaration. */
	private void compileClassVarDec() {
		// Opening class variable declaration tag
		writeXML("<classVarDec>");
		indent++;

		// 'static' | 'field'
		advance();

		String scopeRaw = token;

		writeXML(line); // Already error trapped by "compileClass()"

		// type
		advance();
		String type = token;

		if (!validVariableType())
			return;

		writeXML(line); // Can't fully error check unless kept track of all
						// class
						// names.

		// variable name
		advance();
		if (!tokenType.equals("identifier")) {
			System.out.println("The variable has to be an identifier (not a reserved word).");
			return;
		}

		// Add the variable to the SymbolTable
		SymbolTable.VariableScope scope = SymbolTable.VariableScope.FIELD;
		if (scopeRaw.equals("static"))
			scope = SymbolTable.VariableScope.STATIC;

		writeVariable(scope, type);

		writeXML(line);

		// Possible (',', then variable name) | ';'
		while (true) { // Continue until a ';' is found
			advance();

			if (token.equals(";")) {
				writeXML(line);
				break;
			} else if (token.equals(",")) { // Additional variable declarations
				writeXML(line);

				// Make sure that there is a variable identifier after the
				// comma.
				advance();
				if (!tokenType.equals("identifier")) {
					System.out.println("Expected a variable name after the comma in multi-variable declaration.");
					return;
				}
				writeVariable(scope, type);

				writeXML(line);
			}
		}

		indent--;
		writeXML("</classVarDec>");
	}

	/** Compiles a complete method, function, or constructor. */
	private void compileSubroutine() {
		boolean isConstructor;

		symbolTable.startSubroutine();

		// Write the opening subroutine tag
		writeXML("<subroutineDec>");
		indent++;

		// constructor | function | method (error trapped by "compileClass()")
		advance();
		writeXML(line);
		isMethod = token.equals("method");

		isConstructor = token.equals("constructor");

		// void | type
		advance();

		if (!token.equals("void") && !validVariableType()) {
			System.out.println("Expected a valid variable type or void for the subroutine's return value.");
			return;
		}

		isVoid = token.equals("void");

		writeXML(line);

		// subroutine name
		advance();

		if (!tokenType.equals("identifier")) {
			System.out.println("The subroutine's name should be an identifier.");
			return;
		}

		String subroutineName = token;

		writeXML(line);

		// '('
		advance();

		if (!token.equals("(")) {
			System.out.println("Expected a '(' after the subroutine name.");
			return;
		}

		writeXML(line);

		// parameter list
		compileParameterList();

		// ')'
		advance();
		if (!token.equals(")")) {
			System.out.println("Expected ')' after the parameters in the parameter list.");
		}
		writeXML(line);

		// subroutine body '{' varDec* statements '}'
		advance();

		if (!token.equals("{")) {
			System.out.println("Expected an opening brace after the parameter list in the subroutine.");
			return;
		}

		writeXML("<subroutineBody>");
		indent++;

		writeXML(line);

		while (true) { // Keep looking for variable declarations and
						// statement(s) until a '}' is reached.
			advance();

			if (token.equals("var")) { // Look for variable declarations
				stepBack();
				compileVarDec();
			} else { // Compile statements after variable declarations
				// Write the VM function code
				vm.writeFunction(className + '.' + subroutineName, symbolTable.varCount(SymbolTable.VariableScope.VAR));

				// Write the allocation for local variables if the subroutine is
				// a constructor
				if (isConstructor) {
					vm.writePush("constant", symbolTable.varCount(SymbolTable.VariableScope.FIELD));
					vm.writeCall("Memory.alloc", 1);
					vm.writePop("pointer", 0); // Set "this"
				} else if (isMethod) {
					// Push the this value to the stack
					vm.writePush("argument", 0);
					// Align the "this" segment
					vm.writePop("pointer", 0);
				}

				stepBack();
				compileStatements();

				// '}'
				advance();
				if (!token.equals("}")) {
					System.out.println("Expected a closing brace after the statements in a subroutine.");
					break;
				}

				writeXML(line);
				break;
			}
		}

		indent--;
		writeXML("</subroutineBody>");

		indent--;
		writeXML("</subroutineDec>");
	}

	/**
	 * Compiles a (possibly empty) parameter list, not including the enclosing
	 * "()".
	 */
	private void compileParameterList() {
		// Write the opening parameter list tag
		writeXML("<parameterList>");
		indent++;

		boolean firstVarDeclared = false;

		// Loop until variable declarations are finished
		while (true) {
			advance();

			if (token.equals(")")) { // End of parameter list
				stepBack();

				indent--;
				writeXML("</parameterList>");
				break;
			} else { // New variable declaration
				if (firstVarDeclared) { // Then look for a ','
					if (!token.equals(",")) {
						System.out.println("Expected a comma after first variable declaration in parameter list.");
						return;
					}

					writeXML(line);

					// type
					advance();
				}

				String type = token;
				if (!validVariableType())
					return;

				writeXML(line);

				// variable name
				advance();
				writeVariable(SymbolTable.VariableScope.ARG, type);

				if (!tokenType.equals("identifier")) {
					System.out.println("Expected variable name to be an identifier.");
					return;
				}

				writeXML(line);

				firstVarDeclared = true;
			}
		}
	}

	/** Compiles a var declaration. */
	private void compileVarDec() {
		writeXML("<varDec>");
		indent++;

		// "var"
		advance();
		writeXML(line);

		// type
		advance();
		String type = token;

		if (!validVariableType())
			return;

		writeXML(line);

		// Loop until a semicolon is found
		boolean firstVarDeclared = false;

		while (true) {
			advance();

			if (token.equals(";")) { // Ending ';'
				writeXML(line);

				indent--;
				writeXML("</varDec>");
				break;
			} else { // New variable declaration
				if (firstVarDeclared) {
					if (!token.equals(",")) {
						System.out.println("Expected a comma between variable declarations in varDec.");
						return;
					}

					writeXML(line);

					advance();
				}

				if (!tokenType.equals("identifier")) {
					System.out.println("Expected the variable name to be an identifier.");
					return;
				}

				// Add the new variable to the SymbolTable
				writeVariable(SymbolTable.VariableScope.VAR, type);

				writeXML(line);

				firstVarDeclared = true;
			}
		}
	}

	/** Compiles a sequence of statements, not including the enclosing "{}". */
	private void compileStatements() {
		writeXML("<statements>");
		indent++;

		// Keep looping until the statements are fully compiled
		while (true) {
			advance();

			String type = "";

			// Only write the opening tag only if the next statement is valid
			for (String statementType : statementTypes)
				if (statementType.equals(token)) {
					writeXML("<" + token + "Statement>");
					indent++;
					type = token;
					stepBack();
					break;
				}

			if (type.equals("let"))
				compileLet();
			else if (type.equals("if"))
				compileIf();
			else if (type.equals("while"))
				compileWhile();
			else if (type.equals("do"))
				compileDo();
			else if (type.equals("return"))
				compileReturn();
			else {
				stepBack();
				break;
			}

			indent--;
			writeXML("</" + type + "Statement>");
		}

		indent--;
		writeXML("</statements>");
	}

	/** Compiles a do statement. */
	private void compileDo() {
		// "do"
		advance();
		writeXML(line);

		// subroutineCall
		compileSubroutineCall();

		// Move it onto the "temp" segment because its value does not need to be
		// stored, but it shouldn't be left on the stack
		vm.writePop("temp", 0);

		// ';'
		advance();

		if (!token.equals(";")) {
			System.out.println("Expected a semicolon after \"do\" statement.");
			return;
		}

		writeXML(line);
	}

	/** Compiles a let statement. */
	private void compileLet() {
		boolean isArray = false;

		// "let"
		advance();
		writeXML(line);

		// varName
		advance();

		if (!tokenType.equals("identifier")) {
			System.out.println("In \"let\" statement the variable name should be an identifier.");
			return;
		}
		String varName = token;
		writeVariable(SymbolTable.VariableScope.NONE, "");

		writeXML(line);

		// Possibly: '['
		advance();

		if (token.equals("[")) {
			isArray = true;

			writeXML(line);

			// expression
			compileExpression();

			// ']'
			advance();
			if (!token.equals("]")) {
				System.out.println("No closing bracket in array indexing.");
				return;
			}

			// Push the array base and add it to the expression in the brackets.
			vm.writePush(SymbolTable.scopeSegment(symbolTable.kindOf(varName)), symbolTable.indexOf(varName));
			vm.writeArithmetic(VMWriter.Operation.ADD);

			writeXML(line);
			advance();
		}

		// '='
		if (!token.equals("=")) {
			System.out.println("Expected '=' in \"let\" statement.");
			return;
		}

		writeXML(line);

		// expression
		compileExpression();

		if (isArray) {
			// Pop the intended value onto the temp segment
			vm.writePop("temp", 0);
			// Pop the value of the array base + index onto pointer 1 (makes it
			// so that "that[0]" is the index of the destination on the array).
			vm.writePop("pointer", 1);
			// Push the value of the intended value back on the stack.
			vm.writePush("temp", 0);
			// Move the value onto the array
			vm.writePop("that", 0);
		} else {
			// Write the VM code that puts the result in the variable
			vm.writePop(SymbolTable.scopeSegment(symbolTable.kindOf(varName)), symbolTable.indexOf(varName));
		}

		// ';'
		advance();
		if (!token.equals(";")) {
			System.out.println("Expected ';' at end of let statement.");
			return;
		}

		writeXML(line);
	}

	/** Compiles a while statement. */
	private void compileWhile() {
		String start = VMWriter.uniqueLabel("WHILE_EXP"), end = VMWriter.uniqueLabel("WHILE_END");
		// "while"
		advance();
		writeXML(line);

		// '('
		advance();

		if (!token.equals("(")) {
			System.out.println("Expected '(' after \"while\" keyword.");
			return;
		}

		writeXML(line);

		vm.writeLabel(start);

		// expression
		compileExpression();

		// Negate the conditional in the while loop because if the condition is
		// false, then we want to jump to the end of the loop. If the condition
		// is false then jump to the end of the loop.
		vm.writeArithmetic(VMWriter.Operation.NOT);
		vm.writeIf(end);

		// ')'
		advance();
		if (!token.equals(")")) {
			System.out.println("Expected ')' after expression in \"while\" statement.");
			return;
		}

		writeXML(line);

		// '{'
		advance();
		if (!token.equals("{")) {
			System.out.println("Expected '{' after ')' in \"while\" statement.");
			return;
		}

		writeXML(line);

		// statements
		compileStatements();

		// '}'
		advance();
		if (!token.equals("}")) {
			System.out.println("Expected '}' after statments in \"while\" statement.");
			return;
		}

		writeXML(line);

		vm.writeGoto(start);
		vm.writeLabel(end);
	}

	/** Compiles a return statement. */
	private void compileReturn() {
		// "return"
		advance();
		writeXML(line);

		// expression? | ';'
		advance();

		if (token.equals(";")) {
			writeXML(line);
		} else {
			stepBack();
			compileExpression();

			// ';'
			advance();
			if (!token.equals(";")) {
				System.out.println("Expected ';' after expression in \"return\" statement.");
				return;
			}

			writeXML(line);
		}
		// Push the value 0 to the stack before returning if the subroutine that
		// it is returning from is void
		if (isVoid)
			vm.writePush("constant", 0);

		vm.writeReturn();
	}

	/** Compiles an if statement, possibly with a trailing else clause. */
	private void compileIf() {
		String trueLabel = VMWriter.uniqueLabel("IF_TRUE"), endLabel = VMWriter.uniqueLabel("IF_END"),
				elseLabel = VMWriter.uniqueLabel("IF_FALSE");

		// "if"
		advance();
		writeXML(line);

		// '('
		advance();

		if (!token.equals("(")) {
			System.out.println("Expected '(' after \"if\" keyword.");
			return;
		}

		writeXML(line);

		// expression
		compileExpression();

		vm.writeIf(trueLabel);
		vm.writeGoto(elseLabel);
		vm.writeLabel(trueLabel);

		// ')'
		advance();
		if (!token.equals(")")) {
			System.out.println("Expected ')' after expression in if statement.");
			return;
		}

		writeXML(line);

		// '{'
		advance();

		if (!token.equals("{")) {
			System.out.println("Expected a '{' after ')' in if statement.");
			return;
		}

		writeXML(line);

		// statements
		compileStatements();

		// '}'
		advance();
		if (!token.equals("}")) {
			System.out.println("Expected a '}' after statements in if statement.");
			return;
		}

		writeXML(line);

		// Possibly: "else"
		advance();

		if (token.equals("else")) {
			// Go to the end of the if statement past the else clause if the
			// conditional was true.
			vm.writeGoto(endLabel);
			vm.writeLabel(elseLabel);

			writeXML(line);

			// '{'
			advance();

			if (!token.equals("{")) {
				System.out.println("Expected a '{' after \"else\" keyword.");
				return;
			}

			writeXML(line);

			// statements
			compileStatements();

			// '}'
			advance();
			if (!token.equals("}")) {
				System.out.println("Expected a '}' after statements in else statement.");
				return;
			}
			vm.writeLabel(endLabel);
		} else { // Return if no "else" statements
			stepBack();
			vm.writeLabel(elseLabel);
			return;
		}
	}

	/** Compiles an expression. */
	private void compileExpression() {
		writeXML("<expression>");
		indent++;

		compileTerm();

		// Keep looping until "(op term)" is complete
		while (true) {
			advance();

			// op
			boolean valid = false;

			for (char op : opVals)
				if (op == token.charAt(0))
					valid = true;

			char op = token.charAt(0);

			if (!valid) {
				stepBack();
				break;
			}

			writeXML(line);

			// term
			compileTerm();

			// { '+', '-', '*', '/', '&', '|', '<', '>', '=' };
			switch (op) {
			case '+':
				vm.writeArithmetic(VMWriter.Operation.ADD);
				break;
			case '-':
				vm.writeArithmetic(VMWriter.Operation.SUB);
				break;
			case '*':
				vm.writeCall("Math.multiply", 2);
				break;
			case '/':
				vm.writeCall("Math.divide", 2);
				break;
			case '&':
				vm.writeArithmetic(VMWriter.Operation.AND);
				break;
			case '|':
				vm.writeArithmetic(VMWriter.Operation.OR);
				break;
			case '<':
				vm.writeArithmetic(VMWriter.Operation.LT);
				break;
			case '>':
				vm.writeArithmetic(VMWriter.Operation.GT);
				break;
			case '=':
				vm.writeArithmetic(VMWriter.Operation.EQ);
				break;
			}
		}

		indent--;
		writeXML("</expression>");
	}

	/** Compiles a subroutine call. */
	private void compileSubroutineCall() {
		// class name/var name or subroutine name
		boolean isMethod = false;

		advance();

		if (!tokenType.equals("identifier")) {
			System.out.println("In subroutine call expected either a class name/variable name or subroutine name.");
			return;
		}
		writeVariable(SymbolTable.VariableScope.NONE, "");
		writeXML(line);
		String subroutineName = token;

		// If the first part of the subroutine name is found in the symbol
		// table, then we know that it is an instance of a class, which means
		// that we need to push "this" to the stack
		if (symbolTable.kindOf(subroutineName) != SymbolTable.VariableScope.NONE) {
			vm.writePush(SymbolTable.scopeSegment(symbolTable.kindOf(subroutineName)),
					symbolTable.indexOf(subroutineName));

			// Change the subroutine name to be that of the class
			subroutineName = symbolTable.typeOf(subroutineName);
			isMethod = true;
		}
		// Either '(' or '.'
		advance();

		if (token.equals(".")) {
			writeXML(line);

			// subroutine name
			advance();

			if (!tokenType.equals("identifier")) {
				System.out.println("Expected method name to be an identifier in subroutine call.");
				return;
			}
			writeVariable(SymbolTable.VariableScope.NONE, "");
			writeXML(line);

			subroutineName += "." + token;

			advance();
		} else {
			// If no class or var name was used then the subroutine must be a
			// function call.
			subroutineName = className + "." + subroutineName;
			vm.writePush("pointer", 0);
			isMethod = true;
		}

		// '('
		if (!token.equals("(")) {
			System.out.println("Expected '(' after subroutine name in subroutine call.");
			return;
		}
		writeXML(line);

		// Expression list
		int numArgs = compileExpressionList();
		// Add one more argument if the subroutine is a method because this also
		// is passed in
		if (isMethod)
			numArgs++;

		// ')'
		advance();
		if (!token.equals(")")) {
			System.out.println("Expected ')' after expression list in subroutine call.");
			return;
		}
		writeXML(line);

		vm.writeCall(subroutineName, numArgs);
	}

	/**
	 * Compiles a term. This routine is faced with a slightly difficulty when
	 * trying to decide between some of the alternative parsing rules.
	 * Specifically, if the current token is an identifier, the routine must
	 * distinguish between a variable, an array entry, and a subroutine call. A
	 * single lookahead token, which may be one of "[", "(", "." suffices to
	 * distinguish between the three possibilities. Any other token is not part
	 * of this term and should not be advanced over.
	 */
	private void compileTerm() {
		writeXML("<term>");
		indent++;

		advance();

		if (token.equals("-") || token.equals("~")) {
			String opRaw = token;
			// unaryOp
			writeXML(line);
			compileTerm();

			// Write the unary operators after the term in VM code
			VMWriter.Operation op = VMWriter.Operation.NEG;
			if (opRaw.equals("~"))
				op = VMWriter.Operation.NOT;

			vm.writeArithmetic(op);

			indent--;
			writeXML("</term>");
			return;
		}

		boolean isKeywordConstant = false;

		for (String keyword : keywordConstants)
			if (token.equals(keyword))
				isKeywordConstant = true;

		if (tokenType.equals("integerConstant")) {
			writeXML(line);
			vm.writePush("constant", Integer.parseInt(token));
		} else if (tokenType.equals("stringConstant")) {
			writeXML(line);
			
			vm.writePush("constant", token.length());
			vm.writeCall("String.new", 1);

			for (char c : token.toCharArray()) {
				vm.writePush("constant", c);
				vm.writeCall("String.appendChar", 2);
			}
		} else if (isKeywordConstant) {
			writeXML(line);

			switch (token) {
			case "true":
				vm.writePush("constant", 0);
				vm.writeArithmetic(VMWriter.Operation.NOT);
				break;

			case "null":
			case "false":
				vm.writePush("constant", 0);
				break;

			case "this":
				vm.writePush("pointer", 0);
				break;
			}
		} else if (tokenType.equals("identifier")) {
			writeVariable(SymbolTable.VariableScope.NONE, "");
			// Identifier (varName | varName '[' expression ']' |
			// subroutineCall)
			String identifier = line;
			String identifierToken = token;

			advance();

			if (token.equals("[")) { // Array indexing
				writeXML(identifier);
				writeXML(line);

				// Expression
				compileExpression();

				// Write the VM command that pushes the value of the variable --
				// that is an array -- to the stack and then pops the value onto
				// the virtual "that" segment.
				vm.writePush(SymbolTable.scopeSegment(symbolTable.kindOf(identifierToken)),
						symbolTable.indexOf(identifierToken));

				// Add the base address of the array and the value of the
				// expression inside of the brackets and align the "that"
				// segment to that value.
				vm.writeArithmetic(VMWriter.Operation.ADD);
				vm.writePop("pointer", 1);
				vm.writePush("that", 0);
				// ']'
				advance();
				if (!token.equals("]")) {
					System.out.println("Expected ']' after array indexing.");
					return;
				}

				writeXML(line);
			} else if (token.equals("(") || token.equals(".")) { // Subroutine
																	// call
				stepBack();
				stepBack();
				compileSubroutineCall();
			} else { // Variable
				stepBack();
				writeXML(identifier);

				vm.writePush(SymbolTable.scopeSegment(symbolTable.kindOf(identifierToken)), symbolTable
						.indexOf(identifierToken)
						+ ((symbolTable.kindOf(identifierToken) == SymbolTable.VariableScope.ARG && isMethod) ? 1 : 0));
			}
		} else if (token.equals("(")) {
			// '('
			writeXML(line);

			// Expression
			compileExpression();

			// ')'
			advance();
			writeXML(line);
		} else {
			System.out.println("Invalid term.");
			return;
		}

		indent--;
		writeXML("</term>");
	}

	/**
	 * Compiles a (possibly empty) comma-separated list of expressions. Returns
	 * the number of arguments in the list.
	 */
	private int compileExpressionList() {
		int numExpressions = 0;
		writeXML("<expressionList>");
		indent++;

		advance();

		if (token.equals(")")) {
			stepBack();
		} else {
			stepBack();
			compileExpression();
			numExpressions++;

			// Keep on compiling (',' expression) until complete
			while (true) {
				advance();

				if (token.equals(")")) {
					stepBack();
					break;
				} else if (token.equals(",")) {
					writeXML(line);

					compileExpression();
					numExpressions++;
				} else
					System.out.println("Expected a ',' between expressions in expression list.");
			}
		}
		indent--;
		writeXML("</expressionList>");
		return numExpressions;
	}

	/** Writes a String to the output file and goes to the next line. */
	private void writeXML(String line) {
		String indent = "";

		for (int i = 0; i < this.indent; i++)
			indent += "  ";

		try {
			writer.write(indent + line);
			writer.newLine();
		} catch (IOException e) {
			System.out.println("Failed to write to the *.xml file.");
			e.printStackTrace();
		}
	}

	/**
	 * Prints out variable data from the symbol table (category, defined/used,
	 * index) whenever a variable is encountered or defined.
	 */
	private void writeVariable(SymbolTable.VariableScope category, String type) {
		// Add the variable's information to the symbol table
		if (category != SymbolTable.VariableScope.NONE)
			symbolTable.define(token, type, category);
		else if (symbolTable.kindOf(token) == SymbolTable.VariableScope.NONE)
			// If the variable is not found in the symbol table, then it must be
			// a class name or subroutine name; it does not need to be added to
			// the symbol table
			return;

		// Look up the variable's information in the symbol table
		// System.out.println(
		// "NAME: " + token + " DECLARATION: " +
		// ((category.toString().equals("NONE")) ? "false" : "true")
		// + " TYPE: " + symbolTable.typeOf(token) + " SCOPE: " +
		// symbolTable.kindOf(token) + " #" + symbolTable.indexOf(token));
	}

	/**
	 * Determines whether the current token and type constitute a valid variable
	 * type.
	 */
	private boolean validVariableType() {
		if (!tokenType.equals("identifier") && !token.equals("int") && !token.equals("boolean")
				&& !token.equals("char")) {
			System.out.println("The variable is not of a valid type (must be a int/boolean/char or class name).");

			return false;
		}

		return true;
	}

	/**
	 * Goes back a line in the file and sets "token" and "tokenType"
	 * accordingly.
	 */
	private void stepBack() {
		lineNumber -= 2;
		advance();
	}
}
